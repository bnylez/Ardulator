# -*- coding: utf-8 -*-
"""ardulator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WdQwvc7xLXaKscg3oaDfIajQTdDF6nBz
"""

class CreditCard:
    def __init__(self, card_number, brand, interest_rate, minimum_payment, balance):
        self.details = {
            'card_number': card_number,
            'brand': brand,
            'interest_rate': interest_rate,
            'minimum_payment': minimum_payment,
            'balance': balance
        }

class CardCalculator:
    def __init__(self, cards):
        self.cards = cards  # cards should be a list of CreditCard instances

    def calculate_total_minimum_payment(self):
        # This loops through the list of CreditCard objects
        return sum(card.details['minimum_payment'] for card in self.cards)

    def calculate_payoff_time(self):
        results = []  # This list will hold the results for all cards
        for card in self.cards:
            balance = card.details['balance']
            monthly_interest_rate = card.details['interest_rate'] / 12 / 100
            minimum_payment = card.details['minimum_payment']
            months = 0
            if minimum_payment <= balance * monthly_interest_rate:
                results.append((card.details['card_number'], 'Infinity - minimum payment too low to cover interest'))
                continue  # Skip to the next card
            while balance > 0:
                interest = balance * monthly_interest_rate
                balance += interest - minimum_payment
                if balance < 0:
                    balance = 0  # Adjust for overpayment in the final month
                months += 1

            results.append((card.details['card_number'], months))  # Append results for each card

        return results  # Make sure to return the accumulated results


    def calculate_total_interest_paid(self):
        results = []
        for card in self.cards:
            balance = card.details['balance']
            monthly_interest_rate = card.details['interest_rate'] / 12 / 100
            minimum_payment = card.details['minimum_payment']
            total_interest = 0
            months = 0

            while balance > 0:
                interest = balance * monthly_interest_rate
                balance += interest - minimum_payment
                total_interest += interest
                if minimum_payment > balance + interest:
                    balance -= (interest + balance)  # Adjust the balance to zero if overpaid
                months += 1

            results.append((card.details['card_number'], total_interest))
        return results

def collect_credit_card_data():
    cards = []
    card_number = 1
    total_minimum_payment = 0

    while True:
        print(f"\nEntering details for Card #{card_number}")
        brand = input("Enter the brand of the credit card: ")
        interest_rate = float(input("Enter the interest rate (%): "))
        minimum_payment = float(input("Enter the minimum payment ($): "))
        balance = float(input("Enter the balance ($): "))

        card = CreditCard(card_number, brand, interest_rate, minimum_payment, balance)
        cards.append(card)
        total_minimum_payment += minimum_payment

        another = input("Would you like to enter another card? (yes/no): ")
        if another.lower() != 'yes':
            break
        card_number += 1

    return cards, total_minimum_payment

class DebtCalculations:
    def __init__(self, cards):
        self.cards = cards

    def survival_payments(self, payment_amount):
        # Calculate how many months the user can cover minimum payments with the total payment amount
        total_min_payment = sum(card.details['minimum_payment'] for card in self.cards)
        months = 0
        while payment_amount >= total_min_payment:
            payment_amount -= total_min_payment
            months += 1
        return months

    def avalanche_payments(self, payment_amount):
        # Sort cards by highest interest rate first for optimal payment
        sorted_cards = sorted(self.cards, key=lambda x: x.details['interest_rate'], reverse=True)
        payments = {}
        remaining_payment = payment_amount

        # First pass: assign minimum payments to each card
        for card in sorted_cards:
            if remaining_payment >= card.details['minimum_payment']:
                payments[card.details['card_number']] = card.details['minimum_payment']
                remaining_payment -= card.details['minimum_payment']
            else:
                # If we run out of funds before covering all minimum payments
                payments[card.details['card_number']] = remaining_payment
                remaining_payment = 0

        # Second pass: allocate remaining funds to the highest interest cards first
        if remaining_payment > 0:
            for card in sorted_cards:
                additional_payment = min(remaining_payment, card.details['balance'] - payments[card.details['card_number']])
                payments[card.details['card_number']] += additional_payment
                remaining_payment -= additional_payment
                if remaining_payment <= 0:
                    break

        return payments


    def calculate_total_interest_with_payments(self, payment_amount, strategy):
        # Calculate total interest paid across all cards given a payment strategy
        total_interest_paid = 0
        sorted_cards = sorted(self.cards, key=lambda x: x.details['interest_rate'], reverse=(strategy == 1))

        for card in sorted_cards:
            balance = card.details['balance']
            monthly_interest_rate = card.details['interest_rate'] / 12 / 100
            while balance > 0 and payment_amount > 0:
                interest = balance * monthly_interest_rate
                total_interest_paid += interest
                payment = min(payment_amount, balance + interest)
                balance += interest - payment
                payment_amount -= payment

                if balance < 0:
                    balance = 0

        return total_interest_paid

def main():
    print("Welcome to Ardulator!")
    cards, total_minimum_payment = collect_credit_card_data()
    card_calculator = CardCalculator(cards)
    debt_calculations = DebtCalculations(cards)

    want_to_pay = input("Would you like to make a payment? (yes/no): ").lower()

    if want_to_pay == 'no':
        payoff_times = card_calculator.calculate_payoff_time()
        total_interests = card_calculator.calculate_total_interest_paid()

        for (card_number, months), (_, total_interest) in zip(payoff_times, total_interests):
            print(f"Card #{card_number} will take {months} months to payoff, accumulating ${total_interest:.2f} in interest.")

        print(f"Total minimum payment for all cards: ${total_minimum_payment:.2f}")

    else:
        payment_amount = float(input("Enter the total payment amount ($): "))
        payment_strategy = int(input("Enter payment type (0 for Avalanche, 1 for Survival): "))

        if payment_strategy == 0:
            payments = debt_calculations.avalanche_payments(payment_amount)
            for card_number, payment in payments.items():
                print(f"Card #{card_number} should be paid ${payment:.2f} this cycle.")

            total_interest = debt_calculations.calculate_total_interest_with_payments(payment_amount, 0)
            print(f"Total interest accrued this month: ${total_interest:.2f}")

        elif payment_strategy == 1:
            months = debt_calculations.survival_payments(payment_amount)
            print(f"You can cover minimum payments for {months} months with the payment of ${payment_amount:.2f}.")

            total_interest = debt_calculations.calculate_total_interest_with_payments(payment_amount, 1)
            print(f"Total interest accrued this month: ${total_interest:.2f}")

if __name__ == "__main__":
    main()
main()